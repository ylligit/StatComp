library("StatComp20006", lib.loc="~/R/win-library/4.0")
detach("package:StatComp20006", unload=TRUE)
devtools::document()
devtools::check()
\devtools::document()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
inter.points <- function(k){
S = function(a,k){
ck = sqrt(a^2*k/(k+1-a^2))
pt(ck,df=k,lower.tail=FALSE)
}
solve = function(k){
output = uniroot(function(a){S(a,k)-S(a,k-1)},lower=1,upper=2)
output$root
}
root = matrix(0,2,length(k))
for (i in 1:length(k)){
root[2,i]=round(solve(k[i]),4)
}
root[1,] = k
rownames(root) = c('k','A(k)')
root
}
k = c(4:25,100,500,1000)
root <- inter.points(k)
root
devtools::document()
devtools::check()
save(mtcars,file = "F:/USTC/2020autumn/statcompute/StatComp20006/data/mtcars.rda",compress = TRUE)
save(faithful,file = "F:/USTC/2020autumn/statcompute/StatComp20006/data/faithful.rda",compress = TRUE)
devtools::document()
devtools::document()
devtools::build_vignettes()
devtools::build()
Gelman.Rubin <- function(psi) {
# psi[i,j] is the statistic psi(X[i,1:j])
# for chain in i-th row of X
psi <- as.matrix(psi)
n <- ncol(psi)
k <- nrow(psi)
psi.means <- rowMeans(psi) #row means
B <- n * var(psi.means) #between variance est.
psi.w <- apply(psi, 1, "var") #within variances
W <- mean(psi.w) #within est.
v.hat <- W*(n-1)/n + (B/n) #upper variance est.
r.hat <- v.hat / W #G-R statistic
return(r.hat)
}
k <- 4    # four chains
x0 <- c(-10,-5,5,10)    # overdispersed initial values
N <- 10000    # length of chains
b <- 200    # burn-in length
par(mfrow=c(2,2))
X <- matrix(nrow=k,ncol=N)
for (i in 1:k)
X[i,] <- rwMetropolisR(N,0.5,x0[i])$x
psi <- t(apply(X, 1, cumsum))
for (i in 1:nrow(psi))
psi[i,] <- psi[i,] / (1:ncol(psi))
rhat <- rep(0, N)
for (j in (1000+1):N)
rhat[j] <- Gelman.Rubin(psi[,1:j])
plot(rhat[(1000+1):N], type="l", xlab="sigma=0.5", ylab="R_hat")
abline(h=1.2, lty=2)
X <- matrix(nrow=k,ncol=N)
for (i in 1:k)
X[i,] <- rwMetropolisR(N,1,x0[i])$x
psi <- t(apply(X, 1, cumsum))
for (i in 1:nrow(psi))
psi[i,] <- psi[i,] / (1:ncol(psi))
rhat <- rep(0, N)
for (j in (500+1):N)
rhat[j] <- Gelman.Rubin(psi[,1:j])
x2 <- min(which(rhat>0 & rhat<1.2))
plot(rhat[(500+1):N], type="l", xlab="sigma=1", ylab="R_hat")
abline(h=1.2, lty=2)
X <- matrix(nrow=k,ncol=N)
for (i in 1:k)
X[i,] <- rwMetropolisR(N,4,x0[i])$x
psi <- t(apply(X, 1, cumsum))
for (i in 1:nrow(psi))
psi[i,] <- psi[i,] / (1:ncol(psi))
rhat <- rep(0, N)
for (j in (b+1):N)
rhat[j] <- Gelman.Rubin(psi[,1:j])
x3 <- min(which(rhat>0 & rhat<1.2))
plot(rhat[(b+1):N], type="l", xlab="sigma=4", ylab="R_hat")
abline(h=1.2, lty=2)
X <- matrix(nrow=k,ncol=N)
for (i in 1:k)
X[i,] <- rwMetropolisR(N,16,x0[i])$x
psi <- t(apply(X, 1, cumsum))
for (i in 1:nrow(psi))
psi[i,] <- psi[i,] / (1:ncol(psi))
rhat <- rep(0, N)
for (j in (b+1):N)
rhat[j] <- Gelman.Rubin(psi[,1:j])
x4 <- min(which(rhat>0 & rhat<1.2))
plot(rhat[(b+1):N], type="l", xlab="sigma=16", ylab="R_hat")
abline(h=1.2, lty=2)
par(mfrow=c(2,2))
set.seed(123)
X <- matrix(nrow=k,ncol=N)
for (i in 1:k)
X[i,] <- rwMetropolisR(N,0.5,x0[i])$x
psi <- t(apply(X, 1, cumsum))
for (i in 1:nrow(psi))
psi[i,] <- psi[i,] / (1:ncol(psi))
rhat <- rep(0, N)
for (j in (1000+1):N)
rhat[j] <- Gelman.Rubin(psi[,1:j])
plot(rhat[(1000+1):N], type="l", xlab="sigma=0.5", ylab="R_hat")
abline(h=1.2, lty=2)
X <- matrix(nrow=k,ncol=N)
for (i in 1:k)
X[i,] <- rwMetropolisR(N,1,x0[i])$x
psi <- t(apply(X, 1, cumsum))
for (i in 1:nrow(psi))
psi[i,] <- psi[i,] / (1:ncol(psi))
rhat <- rep(0, N)
for (j in (500+1):N)
rhat[j] <- Gelman.Rubin(psi[,1:j])
x2 <- min(which(rhat>0 & rhat<1.2))
plot(rhat[(500+1):N], type="l", xlab="sigma=1", ylab="R_hat")
abline(h=1.2, lty=2)
X <- matrix(nrow=k,ncol=N)
for (i in 1:k)
X[i,] <- rwMetropolisR(N,4,x0[i])$x
psi <- t(apply(X, 1, cumsum))
for (i in 1:nrow(psi))
psi[i,] <- psi[i,] / (1:ncol(psi))
rhat <- rep(0, N)
for (j in (b+1):N)
rhat[j] <- Gelman.Rubin(psi[,1:j])
x3 <- min(which(rhat>0 & rhat<1.2))
plot(rhat[(b+1):N], type="l", xlab="sigma=4", ylab="R_hat")
abline(h=1.2, lty=2)
X <- matrix(nrow=k,ncol=N)
for (i in 1:k)
X[i,] <- rwMetropolisR(N,16,x0[i])$x
psi <- t(apply(X, 1, cumsum))
for (i in 1:nrow(psi))
psi[i,] <- psi[i,] / (1:ncol(psi))
rhat <- rep(0, N)
for (j in (b+1):N)
rhat[j] <- Gelman.Rubin(psi[,1:j])
x4 <- min(which(rhat>0 & rhat<1.2))
plot(rhat[(b+1):N], type="l", xlab="sigma=16", ylab="R_hat")
abline(h=1.2, lty=2)
par(mfrow=c(1,1))
devtools::document()
devtools::document()
devtools::build_vignettes()
devtools::build_vignettes()
devtools::build_vignettes()
devtools::check()
count5test = function(x, y) {
X = x - mean(x)
Y = y - mean(y)
outx = sum(X > max(Y)) + sum(X < min(Y))
outy = sum(Y > max(X)) + sum(Y < min(X))
# return 1 (reject) or 0 (do not reject H0)
return(as.integer(max(c(outx, outy)) > 5))
}
n1 <- n2 <- 20
mu1 <- mu2 <- 0
sigma1 <- 1
sigma2 <- 2
alphahat <- mean(replicate(m,expr={
x=rnorm(n1,mu1,sigma1)
y=rnorm(n2,mu2,sigma2)
count5test(x,y)
}))
m <- 1e3
alphahat <- mean(replicate(m,expr={
x=rnorm(n1,mu1,sigma1)
y=rnorm(n2,mu2,sigma2)
count5test(x,y)
}))
count5test_permutation <- function(z,R){
permutation <- function(z){
n <- length(z)
x <- z[1:(n/2)]
y <- z[-(1:(n/2))]
X <- x-mean(x)
Y <- y-mean(y)
outx <- sum(X > max(Y)) + sum(X < min(Y))
outy <- sum(Y > max(X)) + sum(Y < min(X))
as.integer(max(c(outx,outy))>5)
}
n <- length(z)
out <- numeric(R)
for(r in 1:R){
p <- sample(1:n,n,replace = FALSE)
out[r] <- permutation(z[p])
}
sum(out)/R
}
n2 <- 50
sigma2 <- 1
x=rnorm(n1,mu1,sigma1)
y=rnorm(n2,mu2,sigma2)
z=c(x,y)
R <- 1000
count5test_permutation(z,R)
alphahat2 = mean(replicate(m, expr={
x = rnorm(n1, mu1, sigma1)
y = rnorm(n2, mu2, sigma2)
x = x - mean(x) #centered by sample mean
y = y - mean(y)
z = c(x,y)
permutation(z,1000)
}))
alphahat2 = mean(replicate(m, expr={
x = rnorm(n1, mu1, sigma1)
y = rnorm(n2, mu2, sigma2)
x = x - mean(x) #centered by sample mean
y = y - mean(y)
z = c(x,y)
count5test_permutation(z,1000)
}))
eqdist.nn <- function(z,sizes,k,R){
Tn <- function(z, ix, sizes,k) {
n1 <- sizes[1]; n2 <- sizes[2]; n <- n1 + n2
if(is.vector(z)) z <- data.frame(z,0);
z <- z[ix, ];
NN <- nn2(data=z, k=k+1) # what's the first column?
block1 <- NN$nn.idx[1:n1,-1]
block2 <- NN$nn.idx[(n1+1):n,-1]
i1 <- sum(block1 < n1 + .5); i2 <- sum(block2 > n1+.5)
(i1 + i2) / (k * n)
}
boot.obj <- boot(data=z,statistic=Tn,R=R,
sim = "permutation", sizes = sizes,k=k)
ts <- c(boot.obj$t0,boot.obj$t)
p.value <- mean(ts>=ts[1])
list(statistic=ts[1],p.value=p.value)
}
m <- 1e2; k <- 3; p <- 2; mu <- 0.6
n1 <- n2 <- 20; R <- 999; N = c(n1,n2)
set.seed(1234)
p.values <- numeric(m)
for(i in 1:m){
x <- matrix(rnorm(n1*p),ncol=p)
y <- matrix(rnorm(n2*p, mean = mu),ncol = p)
z <- rbind(x,y)
p.values[i,1] <- eqdist.nn(z,sizes=N,k=k,R=R)$p.value}
for(i in 1:m){
x <- matrix(rnorm(n1*p),ncol=p)
y <- matrix(rnorm(n2*p, mean = mu),ncol = p)
z <- rbind(x,y)
p.values[i] <- eqdist.nn(z,sizes=N,k=k,R=R)$p.value}
library(boot)
for(i in 1:m){
x <- matrix(rnorm(n1*p),ncol=p)
y <- matrix(rnorm(n2*p, mean = mu),ncol = p)
z <- rbind(x,y)
p.values[i] <- eqdist.nn(z,sizes=N,k=k,R=R)$p.value}
library(RANN)
install.packages("RANN")
library(RANN)
for(i in 1:m){
x <- matrix(rnorm(n1*p),ncol=p)
y <- matrix(rnorm(n2*p, mean = mu),ncol = p)
z <- rbind(x,y)
p.values[i] <- eqdist.nn(z,sizes=N,k=k,R=R)$p.value}
alpha <- 0.1
pow <- colMeans(p.values<alpha)
pow
pow <- mean(p.values<alpha)
devtools::document()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::build()
devtools::build_vignettes()
devtools::build_vignettes()
install.packages("Ball")
devtools::build_vignettes()
install.packages("energy")
library(MASS)
devtools::build_vignettes()
devtools::build_vignettes()
devtools::build()
jack_correlation <- function(x,y){
n <- length(x)
theta_hat <- cor(x,y)
theta_jack <- numeric(n)
for(i in 1:n){
theta_jack[i] <- cor(x[-i],y[-i])
}
bias_jack <- (n-1)*(mean(theta_jack)-theta_hat)
se_jack <- sqrt((n-1)*mean((theta_jack-mean(theta_jack))^2))
c(bias_jack = bias_jack,se_jack = se_jack)
}
library(bootstrap)
install.packages("bootstrap")
library(bootstrap)
jack_correlation(law$LSAT,law$GPA)
save(law,file = "F:/USTC/2020autumn/statcompute/StatComp20006/data/law.rda",compress = TRUE)
devtools::document()
library(boot)
aircondit <- as.matrix(aircondit)
boot.mean <- function(x,i) mean(x[i])
boot.obj <- boot(aircondit, statistic=boot.mean, R=2000)
boot.ci <- boot.ci(boot.obj, type = c("norm","basic","perc","bca"))
View(boot.ci)
save(aircondit,file = "F:/USTC/2020autumn/statcompute/StatComp20006/data/aircondit.rda",compress = TRUE)
load("F:/USTC/2020autumn/statcompute/StatComp20006/data/aircondit.rda")
devtools::document()
devtools::document()
boot_ci <- function(x){
boot.mean <- function(x,i) mean(x[i])
boot.obj <- boot(x,statistic = boot.mean,R=2000)
boot.ci(boot.obj,type = c("norm","basic","perc","bca"))
}
aircondit <- as.matrix(aircondit)
boot_ci(aircondit)
jack_pca <- function(X){
n <- nrow(X)
lambda_hat = eigen(cov(X))$values
theta_hat = lambda_hat[1] / sum(lambda_hat)
theta_j = rep(0,n)
for (i in 1:n) {
x = X[-i,]
lambda = eigen(cov(x))$values
theta_j[i] = lambda[1]/sum(lambda)
}
#estimated bias of theta_hat
bias_jack = (n-1)*(mean(theta_j)-theta_hat)
#estimated se of theta_hat
se_jack = (n-1)*sqrt(var(theta_j)/n)
c(bias_jack = bias_jack,se_jack=se_jack)
}
jack_pca(scor)
save(scor,file = "F:/USTC/2020autumn/statcompute/StatComp20006/data/scor.rda",compress = TRUE)
load("F:/USTC/2020autumn/statcompute/StatComp20006/data/scor.rda")
devtools::document()
devtools::document()
library(DAAG)
install.packages("DAAG")
library(DAAG)
ironslag
leave2out_cv(X,Y){
n <- length(X)
e1 <- e2 <- e3 <- e4 <- matrix(0,n*(n-1)/2,2)
for(i in 2:n){
for(j in 1:(i-1)){
k <- (i-1)*(i-2)/2 + j
y <- Y[-c(i,j)]
x <- X[-c(i,j)]
J1 <- lm(y ~ x)
yhat1 <- J1$coef[1] + J1$coef[2] * X[c(i,j)]
e1[k,] <- Y[c(i,j)]- yhat1
J2 <- lm(y ~ x + I(x^2))
yhat2 <- J2$coef[1] + J2$coef[2] * X[c(i,j)] + J2$coef[3] * X[c(i,j)]^2
e2[k,] <- Y[c(i,j)] - yhat2
J3 <- lm(log(y) ~ x)
logyhat3 <- J3$coef[1] + J3$coef[2] * X[c(i,j)]
yhat3 <- exp(logyhat3)
e3[k,] <- Y[c(i,j)] - yhat3
J4 <- lm(log(y) ~ log(x))
logyhat4 <- J4$coef[1] + J4$coef[2] * log(X[c(i,j)])
yhat4 <- exp(logyhat4)
e4[k,] <- Y[c(i,j)] - yhat4
}
}
c(mean(e1^2), mean(e2^2), mean(e3^2), mean(e4^2))
}
leave2out_cv <- function(X,Y){
n <- length(X)
e1 <- e2 <- e3 <- e4 <- matrix(0,n*(n-1)/2,2)
for(i in 2:n){
for(j in 1:(i-1)){
k <- (i-1)*(i-2)/2 + j
y <- Y[-c(i,j)]
x <- X[-c(i,j)]
J1 <- lm(y ~ x)
yhat1 <- J1$coef[1] + J1$coef[2] * X[c(i,j)]
e1[k,] <- Y[c(i,j)]- yhat1
J2 <- lm(y ~ x + I(x^2))
yhat2 <- J2$coef[1] + J2$coef[2] * X[c(i,j)] + J2$coef[3] * X[c(i,j)]^2
e2[k,] <- Y[c(i,j)] - yhat2
J3 <- lm(log(y) ~ x)
logyhat3 <- J3$coef[1] + J3$coef[2] * X[c(i,j)]
yhat3 <- exp(logyhat3)
e3[k,] <- Y[c(i,j)] - yhat3
J4 <- lm(log(y) ~ log(x))
logyhat4 <- J4$coef[1] + J4$coef[2] * log(X[c(i,j)])
yhat4 <- exp(logyhat4)
e4[k,] <- Y[c(i,j)] - yhat4
}
}
c(mean(e1^2), mean(e2^2), mean(e3^2), mean(e4^2))
}
attach(ironslag)
cv <- leave2out_cv(chemical,magnetic)
print(cv)
save(ironslag,file = "F:/USTC/2020autumn/statcompute/StatComp20006/data/ironslag.rda",compress = TRUE)
load("F:/USTC/2020autumn/statcompute/StatComp20006/data/ironslag.rda")
devtools::document()
devtools::check()
library(Ball)
devtools::document()
devtools::build_vignettes()
devtools::check()
devtools::document()
devtools::document()
devtools::document()
pwr_F <- function(n,alpha.hat){
mu1 <- mu2 <- 0
sigma1 <- 1
sigma2 <- 1.5
m <- 1e4
result <- matrix(0, length(n), 2)
for (i in 1:length(n)){
ni <- n[i]
tests <- replicate(m, expr={
x <- rnorm(ni, mu1, sigma1)
y <- rnorm(ni, mu2, sigma2)
Fp <- var.test(x, y)$p.value
Ftest <- as.integer(Fp <= alpha.hat)
c(count5test(x, y), Ftest)
})
result[i, ] <- rowMeans(tests)
}
data.frame(n=n, C5=result[, 1], Fp=result[, 2])
}
alpha <- 0.055
n <- c(10,20,50,100)
pwr_F(n,alpha)
devtools::document()
devtools::document()
devtools::check()
devtools::build()
help("mvrnorm")
devtools::build()
devtools::build_vignettes()
devtools::build()
devtools::build_vignettes()
ctl <- c(4.17,5.58,5.18,6.11,4.50,4.61,5.17,4.53,5.33,5.14)
trt <- c(4.81,4.17,4.41,3.59,5.87,3.83,6.03,4.89,4.32,4.69)
group <- gl(2, 10, 20, labels = c("Ctl","Trt"))
weight <- c(ctl, trt)
lm.D9 <- lm(weight ~ group)
par(mfrow=c(2,2))
plot(lm.D9)
devtools::build_vignettes()
devtools::build_vignettes()
devtools::check()
devtools::build()
Sys.which(Sys.getenv("R_QPDF","qpdf"))
devtools::check()
library(FNN)
install.packages("FNN")
library(FNN)
help("knn.dist")
devtools::document()
devtools::document()
install.packages("kedd")
mixnorm <- function(n){
dMG <- function(x) 0.3 * dnorm(x,0,1) + 0.7 * dnorm(x,1,0.3)
rMG <- function(n){
# randomly generate n points from the Mixed Gaussian distribution
r <- runif(n, 0, 1)
x <- r
ind <- which(r < 0.3) #index for those generated from N(0,1)
x[ind] <- rnorm(length(ind), 0, 1)
x[-ind] <- rnorm(n-length(ind), 1, 0.3)
return(x)
}
x <- rMG(n)
fhat.amise <- dkde(x, h = h.amise(x)$h) # BW selection: amise
fhat.bcv <- dkde(x, h = h.bcv(x)$h) # BW selection: bcv
fhat.ccv <- dkde(x, h = h.ccv(x)$h) # BW selection: ccv
plot(dMG, from = -2, to = 3, lwd = 2)
lines(fhat.amise$eval.points, fhat.amise$est.fx, col = 2, lwd = 2)
lines(fhat.bcv$eval.points, fhat.bcv$est.fx, col = 3, lwd = 2)
lines(fhat.ccv$eval.points, fhat.ccv$est.fx, col = 4, lwd = 2)
legend('topleft', legend = c('true', 'amise', 'bcv', 'ccv'),
col = 1:4, lwd = c(2, 2, 2, 2))
return(x)
}
library(kedd)
n <- 100
set.seed(0)
mixnorm(n)
x <- mixnorm(n)
head(x)
devtools::document()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::build()
devtools::build()
devtools::build_vignettes()
devtools::build_vignettes()
library(FNN)
knnx.dist()
devtools::document()
devtools::document()
help("knnx.dist")
devtools::document()
devtools::document()
devtools::document()
devtools::build()
devtools::build_vignettes()
